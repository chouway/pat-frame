package com.pat.starter.oauth.server.config;import com.pat.starter.oauth.server.PatOauthServerStarter;import com.pat.starter.oauth.server.granter.PatEmailCodeTokenGranter;import com.pat.starter.oauth.server.granter.PatMobileCodeTokenGranter;import com.pat.starter.oauth.server.service.PatRedisAuthCodeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.ClassPathResource;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.ClientDetailsService;import org.springframework.security.oauth2.provider.CompositeTokenGranter;import org.springframework.security.oauth2.provider.OAuth2RequestFactory;import org.springframework.security.oauth2.provider.TokenGranter;import org.springframework.security.oauth2.provider.client.ClientCredentialsTokenGranter;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.code.AuthorizationCodeServices;import org.springframework.security.oauth2.provider.code.AuthorizationCodeTokenGranter;import org.springframework.security.oauth2.provider.code.JdbcAuthorizationCodeServices;import org.springframework.security.oauth2.provider.implicit.ImplicitTokenGranter;import org.springframework.security.oauth2.provider.password.ResourceOwnerPasswordTokenGranter;import org.springframework.security.oauth2.provider.refresh.RefreshTokenGranter;import org.springframework.security.oauth2.provider.token.*;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;import org.springframework.security.oauth2.provider.token.store.KeyStoreKeyFactory;import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;import javax.sql.DataSource;import java.util.*;import java.util.concurrent.TimeUnit;/** * 认证配置 * @author: ywzhou * @create: 2020.06.26 **/@Configuration@ConditionalOnProperty(prefix = "app.oauth.server", name = "enabled", havingValue = "true")@EnableAuthorizationServer@AutoConfigureAfter(PatOauthServerStarter.class)public class PatAuthServerConfig extends AuthorizationServerConfigurerAdapter {    @Autowired    private AuthenticationManager authenticationManager;    @Autowired    private UserDetailsService userDetailsService;//    @Autowired//    private ClientDetailsServiceImpl clientDetailsService;    @Autowired    private RedisConnectionFactory redisConnectionFactory;    @Autowired    private DataSource dataSource;    /**     * 配置token存储，这个配置token存到redis中     * @return     */    @Bean    public TokenStore tokenStore() {        return new RedisTokenStore(redisConnectionFactory);//        return new JdbcTokenStore(dataSource);    }    /*@Bean    public ApprovalStore approvalStore(){        //return new TokenApprovalStore();//基于token实现 将        return new JdbcApprovalStore(dataSource);    }*/    /**     * 配置授权码模式授权码服务,不配置默认为内存模式     * @return     */    @Primary    @Bean    public AuthorizationCodeServices authorizationCodeServices() {        PatRedisAuthCodeService patRedisAuthCodeService = new PatRedisAuthCodeService(redisConnectionFactory);        patRedisAuthCodeService.setPrefix("pat");        return patRedisAuthCodeService;//        return new JdbcAuthorizationCodeServices(dataSource);    }    /**     * 配置客户端详情     * @param clients     * @throws Exception     */    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {//      clients.withClientDetails(clientDetailsService);        JdbcClientDetailsService jdbcClientDetailsService = new JdbcClientDetailsService(dataSource);        clients.withClientDetails(jdbcClientDetailsService);    }    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {        // 采用token转jwt，并添加一些自定义信息（token增强）（有默认非必须）        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();        tokenEnhancerChain.setTokenEnhancers(                Arrays.asList(jwtAccessTokenConverter(),tokenEnhancer()));        endpoints.tokenEnhancer(tokenEnhancerChain)                // 配置token存储，一般配置redis存储                .tokenStore(tokenStore())                // 配置认证管理器                .authenticationManager(authenticationManager)                // 配置用户详情server，密码模式必须                .userDetailsService(userDetailsService)                // 配置授权码模式授权码服务,不配置默认为内存模式                .authorizationCodeServices(authorizationCodeServices())                // 配置grant_type模式，如果不配置则默认使用密码模式、简化模式、验证码模式以及刷新token模式，如果配置了只使用配置中，默认配置失效                // 具体可以查询AuthorizationServerEndpointsConfigurer中的getDefaultTokenGranters方法                .tokenGranter(tokenGranter(endpoints));        // 配置TokenServices参数        DefaultTokenServices tokenServices = new DefaultTokenServices();        tokenServices.setTokenStore(endpoints.getTokenStore());        // 是否支持刷新Token        tokenServices.setSupportRefreshToken(true);        tokenServices.setReuseRefreshToken(false);//设置为true时 jdbc下会 token存在处理bug（重复用refreshToken时会导致插入失败）    这个参数表示 refreshToken是否可以重复用在失效前。 使用成功后即失效        tokenServices.setClientDetailsService(endpoints.getClientDetailsService());        tokenServices.setTokenEnhancer(endpoints.getTokenEnhancer());        // 设置accessToken和refreshToken的默认超时时间(如果clientDetails的为null就取默认的，如果clientDetails的不为null取clientDetails中的)        tokenServices.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(2));        tokenServices.setRefreshTokenValiditySeconds((int) TimeUnit.DAYS.toSeconds(30));        endpoints.tokenServices(tokenServices);    }//    @Value("${app.oauth.signingKey}")//    private String signingKey;    private final String serverPwd = "pat-oauth@2022";    private final String serverKey = "pat-oauth";    /**     * jwt格式封装token     * @return     */    @Bean    public JwtAccessTokenConverter jwtAccessTokenConverter() {        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();        // 设置jwt加解密秘钥，不设置会随机一个//        jwtAccessTokenConverter.setSigningKey(signingKey);        // 导入证书  证书可用  （通过 JDK 工具生成 JKS 证书文件，并将 keystore.jks 放入resource目录下）        // 生成指令keytool -genkeypair -alias mytest -keyalg RSA -keypass mypass -keystore keystore.jks -storepass mypass 生成        //win10下 keytool  win10 出现乱码： 解决办法： 在命令行运行chcp 936        KeyStoreKeyFactory keyStoreKeyFactory =                new KeyStoreKeyFactory(new ClassPathResource("META-INF/cert/keystore.jks"), serverPwd.toCharArray());        jwtAccessTokenConverter.setKeyPair(keyStoreKeyFactory.getKeyPair(serverKey));        return jwtAccessTokenConverter;    }    /**     * token增强,添加一些元信息     *     * @return TokenEnhancer     */    @Bean    public TokenEnhancer tokenEnhancer() {        return (accessToken, authentication) -> {            final Map<String, Object> additionalInfo = new HashMap<>(2);            additionalInfo.put("license", "pat");            Authentication userAuthentication = authentication.getUserAuthentication();            if(userAuthentication!=null){//客户端模式没有userAuthetication ywzhou                User user = (User) userAuthentication.getPrincipal();                if (user != null) {                    additionalInfo.put("username", user.getUsername());                }            }            ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);            return accessToken;        };    }    @Override    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {        security                .allowFormAuthenticationForClients()//允许客户端表单提交                .tokenKeyAccess("isAuthenticated()")//tokenKey访问进行鉴权//              .checkTokenAccess("permitAll()");//客户端校验token访问许可permitAll() 可直接访问                .checkTokenAccess("isAuthenticated()");//客户端校验token访问需要带上basic Auth    }    /**     * 创建grant_typ     * @param endpoints     * @return     */    private TokenGranter tokenGranter(AuthorizationServerEndpointsConfigurer endpoints) {        List<TokenGranter> list = new ArrayList<>();        AuthorizationServerTokenServices tokenServices = endpoints.getTokenServices();        OAuth2RequestFactory oAuth2RequestFactory = endpoints.getOAuth2RequestFactory();        ClientDetailsService clientDetailsService = endpoints.getClientDetailsService();        // 这里配置密码模式、刷新token模式、自定义手机号/邮件验证码模式、授权码模式、简化模式、客户端模式        list.add(new ResourceOwnerPasswordTokenGranter(authenticationManager, tokenServices, clientDetailsService, oAuth2RequestFactory));        list.add(new RefreshTokenGranter(tokenServices, clientDetailsService, oAuth2RequestFactory));        list.add(new PatMobileCodeTokenGranter(authenticationManager, tokenServices, clientDetailsService, oAuth2RequestFactory));        list.add(new PatEmailCodeTokenGranter(authenticationManager, tokenServices, clientDetailsService, oAuth2RequestFactory));        list.add(new AuthorizationCodeTokenGranter(tokenServices,endpoints.getAuthorizationCodeServices(), clientDetailsService, oAuth2RequestFactory));        list.add(new ImplicitTokenGranter(tokenServices, clientDetailsService, oAuth2RequestFactory));        ClientCredentialsTokenGranter clientCredentialsTokenGranter = new ClientCredentialsTokenGranter(tokenServices, clientDetailsService, oAuth2RequestFactory);        clientCredentialsTokenGranter.setAllowRefresh(true);        list.add(clientCredentialsTokenGranter);        return new CompositeTokenGranter(list);    }}