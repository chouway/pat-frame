package com.pat.starter.oauth.server.config;import com.pat.api.constant.ErrorCode;import com.pat.starter.oauth.common.access.PatSavedRequestAwareAuthenticationSuccessHandler;import com.pat.starter.oauth.common.access.PatSimpleUrlAuthenticationFailureHandler;import com.pat.starter.oauth.common.util.HttpRespUtil;import com.pat.starter.oauth.server.event.PatAuthFailureListener;import com.pat.starter.oauth.server.filter.PatUsernamePwdAuthenticationFilter;import com.pat.starter.oauth.server.provider.PatEmailCodeAuthProvider;import com.pat.starter.oauth.server.provider.PatMobileCodeAuthProvider;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.http.MediaType;import org.springframework.security.authentication.*;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.*;import javax.annotation.PostConstruct;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * security web安全配置,spring-cloud-starter-oauth2依赖于security *  默认情况下SecurityConfigurerAdapter执行比ResourceServerConfig先 * @author: ywzhou * @create: 2019-09-25 16:49 */@Slf4j@Configuration@EnableWebSecurity@ConditionalOnProperty(prefix = "app.oauth.server", name = "enabled", havingValue = "true")public class PatSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {    @Autowired    private UserDetailsService userDetailsService;    @Autowired    private StringRedisTemplate stringRedisTemplate;    /**     * 配置认证管理器     *     * @return     * @throws Exception     */    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception {        return super.authenticationManagerBean();    }    /**     * 配置密码加密对象（解密时会用到PasswordEncoder的matches判断是否正确）     * 用户的password和客户端clientSecret用到，所以存的时候存该bean encode过的密码     *     * @return     */    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }    /**     * 这里是对认证管理器的添加配置     *     * @param auth     * @throws Exception     */    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        DaoAuthenticationProvider daoAuthenticationProvider = daoProvider(userDetailsService);        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());        auth.authenticationProvider(emailProvider())                .authenticationProvider(mobileProvider())                .authenticationProvider(daoAuthenticationProvider)                .userDetailsService(userDetailsService)                .passwordEncoder(passwordEncoder());    }    @Override    public void configure(WebSecurity web) throws Exception {        web.ignoring().antMatchers("/css/**","/static/**","/signUp.json");    }    /**     *  安全请求配置,这里配置的是security的部分，这里配置全部通过，安全拦截在资源服务的配置文件中配置，     *  要不然访问未验证的接口将重定向到登录页面，前后端分离的情况下这样并不友好，无权访问接口返回相关错误信息即可     * @param http     * @return void     */    @Override    protected void configure(HttpSecurity http) throws Exception {        http.addFilterAt(patUsernamePwdAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);        http                //关闭https严格要求                .headers().httpStrictTransportSecurity().disable()                //需要保护的资源 页面                .and().authorizeRequests().antMatchers("/test/*").authenticated()                .and()                .formLogin().loginPage("/login")                .loginProcessingUrl("/doLogin")                .permitAll();//                .defaultSuccessUrl("/test/loginSuccess");//                .and()//关闭打开的csrf保护   打开需要在登录中增加 <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>//                .csrf().disable()//                .cors();//允许跨域    }    /**     * 自定义手机验证码认证提供者     *     * @return     */    @Bean    public PatMobileCodeAuthProvider mobileProvider() {        PatMobileCodeAuthProvider provider = new PatMobileCodeAuthProvider();        provider.setHideUserNotFoundExceptions(true);        return provider;    }    /**     * 自定义手机验证码认证提供者     *     * @return     */    @Bean    public PatEmailCodeAuthProvider emailProvider() {        PatEmailCodeAuthProvider provider = new PatEmailCodeAuthProvider();        provider.setHideUserNotFoundExceptions(true);        return provider;    }    @Bean    public DaoAuthenticationProvider daoProvider(UserDetailsService userDetailsService) {        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();        provider.setHideUserNotFoundExceptions(true);        provider.setUserDetailsService(userDetailsService);        return provider;    }    @Bean    public PatUsernamePwdAuthenticationFilter patUsernamePwdAuthenticationFilter() throws Exception {        PatUsernamePwdAuthenticationFilter loginFilter = new PatUsernamePwdAuthenticationFilter();        loginFilter.setAuthenticationSuccessHandler(patSavedRequestAwareAuthenticationSuccessHandler());        loginFilter.setAuthenticationFailureHandler(patSimpleUrlAuthenticationFailureHandler());        loginFilter.setAuthenticationManager(authenticationManagerBean());        loginFilter.setFilterProcessesUrl("/doLogin");        return loginFilter;    }    @Bean    public PatSimpleUrlAuthenticationFailureHandler patSimpleUrlAuthenticationFailureHandler(){        return new PatSimpleUrlAuthenticationFailureHandler();    }    @Value("${app.oauth.server.successUrl}")    private  String successUrl;    @Bean    public PatSavedRequestAwareAuthenticationSuccessHandler patSavedRequestAwareAuthenticationSuccessHandler(){        PatSavedRequestAwareAuthenticationSuccessHandler patSavedRequestAwareAuthenticationSuccessHandler = new PatSavedRequestAwareAuthenticationSuccessHandler();        patSavedRequestAwareAuthenticationSuccessHandler.setDefaultTargetUrl(successUrl);        return patSavedRequestAwareAuthenticationSuccessHandler;    }    @Bean    public PatAuthFailureListener patAuthFailureListener(){        return new PatAuthFailureListener();    }}